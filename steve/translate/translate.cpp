#include "translate.hpp"
#include "tostring.hpp"

#include "steve/net.hpp"
#include "steve/lower.hpp"

#include <fstream>
#include <iostream>
#include <string>
#include <stdexcept>

namespace steve
{

namespace
{

// maintain the location of a stmt
// within the sequence of stmts
std::unordered_map<Stmt const*, int> locations_;

// maintains the name of the entrypoint
enum Entry_kind {
  match,
  decode,
};

std::pair<std::string, Entry_kind> entry_;

constexpr int max_extract = 4;

std::string entry_code()
{
  std::string code;
  switch (entry_.second) {
    // we have to dereference the _cxt_ because it is passed
    // via pointer but we want to pass it via reference
    // for the duration of the application runtime
    case Entry_kind::decode:
      code += "__decode(*a, " + entry_.first + ", 0);\n";
      break;
    case Entry_kind::match:
      code += "__match(*a, " + entry_.first + ", 0);\n";
      break;
  }

  return code;
}


// Must extract pipeline before calling this function
std::string app_hpp()
{
  std::string app =
  "#ifndef FP_APP_HPP\n"
  "#define FP_APP_HPP\n"

  "#include \"application.hpp\"\n"
  "#include \"packet.hpp\"\n"
  "#include \"port.hpp\"\n"
  "#include \"lang/include.hpp\"\n"
          "using App_cxt = Application_context<" + std::to_string(get_num_headers()) + ", "
                                                 + std::to_string(get_num_fields()) + ", " 
                                                 + std::to_string(max_extract) +
                                                 ">;\n" +
  "struct Steve_app : fp::Application {\n"
  "  Steve_app(fp::Dataplane&);\n"
  "  ~Steve_app();\n"

  "  void configure();\n"

  "  void start();\n"
  "  void stop();\n"

  "  void add_port(fp::Port*);\n"
  "  void remove_port(fp::Port*);\n"

  "  void ingress(fp::Context*);\n"
  "  void route(fp::Context*);\n"
  "  void egress(fp::Context*);\n"
  "};\n"

  "static void* pipeline(void*);\n"
  "static void* port(void*);\n"


  "struct Factory : fp::Application_factory {"
  "  fp::Application* create(fp::Dataplane&);"
  "  void destroy(fp::Application&);"
  "};\n"
  "#endif";

  return app;
}


std::string cpp_includes()
{
  return
  "#include <iostream>\n"
  "#include <sys/epoll.h>\n"
  "#include <unistd.h>\n"

  "#include \"steve_app.hpp\"\n"
  "#include \"thread.hpp\"\n"
  "#include \"port_udp.hpp\"\n"
  "#include \"port_table.hpp\"\n";
}


std::string statics()
{
  return 
  "static Factory factory_;\n"
  // FIXME: have this line be dynamically generated by steve
  "static fp::Port* ports[4];\n"
  "static fp::Thread_pool<fp::Context*> pipeline_pool(5, pipeline, true);\n"
  "static Steve_app* app;\n"
  "extern fp::Port_table port_table;\n";
}


std::string factory()
{
  return 
  "extern \"C\" void* factory() { return &factory_; }\n"
  "fp::Application* Factory::create(fp::Dataplane& dp) { return new Steve_app(dp); }\n"
  "void Factory::destroy(fp::Application& a) { delete& a; }\n";
}


std::string steve_app()
{
  // FIXME: have the ports line be dynamically generated by steve
  return
  "Steve_app::Steve_app(fp::Dataplane& dp) : fp::Application(dp, \"app\") {"
  "  ports[0] = ports[1] = ports[2] = ports[3] = nullptr;"
  "  app = this;"
  "  std::cout << \"application created\\n\"; }\n"
  "Steve_app::~Steve_app() { std::cout << \"application destroyed\\n\"; }\n"
  "void\n"
  "Steve_app::start()\n"
  "{\n"
  "  // Set ports up.\n"
  "  for (int i = 0; i < 4; ++i)\n"
  "    if (ports[i])\n"
  "      ports[i]->up();    \n"
  "\n"
  "  // Set the run flag.\n"
  "  state = fp::Application::RUNNING;\n"
  "\n"
  "  std::cerr << \"[app] started\\n\";\n"
  "}\n"
  "\n"
  "\n"
  "//\n"
  "void\n"
  "Steve_app::stop()\n"
  "{\n"
  "  // Toggle the run flag.\n"
  "  state = fp::Application::STOPPED;\n"
  "\n"
  "  // Set the ports down.\n"
  "  for (int i = 0; i < 4; i++)\n"
  "    ports[i]->down();\n"
  "\n"
  "  std::cerr << \"[app] stopped\\n\";\n"
  "}\n";
}


std::string static_fn()
{
  return 
  "// The main app processing loop. This routine will be executed by a\n"
  "// separate thread.\n"
  "static void*\n"
  "pipeline(void* args)\n"
  "{\n"
  "  int id = *((int*)args);\n"
  "  fp::Context* cxt = nullptr;\n"
  "\n"
  "  std::cerr << \"[thread:\" << id << \"] starting\\n\";\n"
  "\n"
  "  while(app->state != fp::Application::STOPPED) {\n"
  "    // Get the next packet to be processed, if available.\n"
  "    if (pipeline_pool.request(cxt)) {\n"
  "      // Run it through the pipeline.\n"
  "      app->ingress(cxt);\n"
  "      // FIXME: route really shouldn't be here\n"
  "      // Once you ingress all processing and routing is done by tables\n"
  "      app->route(cxt);\n"
  "      app->egress(cxt);\n"
  "    }\n"
  "  }\n"
  "\n"
  "  std::cerr << \"[thread:\" << id << \"] stopped\\n\";\n"
  "  return 0;\n"
  "}\n"
  "\n"
  "\n"
  "static void* port(void* args)\n"
  "{\n"
  "// Figure out who I am.\n"
  "  int id = *((int*)args);\n"
  "  fp::Port_udp* self = (fp::Port_udp*)ports[id];\n"
  "  fp::Context* cxt;\n"
  "\n"
  "  // Setup (e)polling\n"
  "  int pfd = epoll_create(1);\n"
  "  static struct epoll_event handler, *events;\n"
  "  handler.events = EPOLLIN | EPOLLET;\n"
  "  handler.data.fd = self->sock_fd_;\n"
  "  epoll_ctl(pfd, EPOLL_CTL_ADD, self->sock_fd_, &handler);\n"
  "\n"
  "  // Start rx/tx.\n"
  "  std::cerr << \"[port_thread:\" << id << \"] starting\\n\";\n"
  "  while (app->state != fp::Application::STOPPED) {\n"
  "    // Check for rx (poll). \n"
  "    int n = epoll_wait(pfd, events, 10, -1);\n"
  "    if (n < 0)\n"
  "      throw(\"epoll_wait error\");\n"
  "    else if (n) {\n"
  "      // Receive data.\n"
  "      cxt = self->recv();\n"
  "      \n"
  "      // Assign to the pipeline work queue.\n"
  "      pipeline_pool.assign(cxt);\n"
  "    }\n"
  "\n"
  "    // Check if there is anything to send.\n"
  "    if (self->tx_queue_.size())\n"
  "      self->send();\n"
  "  }\n"
  "  \n"
  "  // Cleanup.\n"
  "  delete[] events;\n"
  "  close(pfd);\n"
  "\n"
  "  std::cerr << \"[thread:\" << id << \"] stopped\\n\";\n"
  "  return 0;\n"
  "}\n";
}


void write_hpp(std::string hpp)
{
  std::ofstream ofs("steve_app.hpp");
  ofs << hpp;
  ofs.close();
}


void write_cpp(std::string cpp)
{
  std::ofstream ofs("steve_app.cpp");
  ofs << cpp;
  ofs.close();
}


} // namespace

// Extract the pipeline and maintain the statement location
// for each pipeline decl.
//
// TODO: provide language feature for explicit declaration of first
// stage in the pipeline. Right now we assume the first declaration is
// the entry point into the pipeline.
void
Translator::extract_pipeline()
{
  int count = 0;

  for (auto stmt : program) {
    // If it is a declaration stmt declaring a pipeline stage
    if (Decl_stmt const* s = as<Decl_stmt>(stmt)) {
      // decode decl
      if (is<Decode_decl>(s->decl())) {
        register_stage(as<Decode_decl>(s->decl()));
        locations_.insert({stmt, count});
      }

      // table decl
      if (is<Table_decl>(s->decl())) {
        register_stage(as<Table_decl>(s->decl()));
        locations_.insert({stmt, count});
      }

      ++count;
    }
  }

  // check the pipeline
  if (check_pipeline()) {
    // get the start of the pipeline so
    // we know how to generate the entry point
    Decl const* start_decl = pipeline_get_start();
    if (is<Decode_decl>(start_decl))
      entry_ = std::make_pair(*start_decl->name(), Entry_kind::decode);
    else if (is<Table_decl>(start_decl))
      entry_ = std::make_pair(*start_decl->name(), Entry_kind::match);
  }
  else
    throw std::runtime_error("Bad pipeline.");
}


void
Translator::lower_pipeline()
{
  for (auto pair : locations_) {
    // now that stuff's been registered we can lower it
    int loc = pair.second;
    Stmt_seq lowered = lower(pair.first);

    program.erase(program.begin() + loc);

    // FIXME: This makes a dangerous assumption that one decl stmt
    // gets lowered to exactly one other decl stmt
    program.insert(program.begin() + loc, lowered.begin(), lowered.end());
  }
}


void
Translator::codegen()
{
  extract_pipeline();
  lower_pipeline();

  // generate header
  std::string hpp = app_hpp();

  // generate cpp
  std::string code = cpp_includes() + statics() + factory() + steve_app() + static_fn();

  for (auto stmt : program) {
    code += tostring(translate(stmt));
  }

  // inject egress code
  code += 
  "void Steve_app::egress(fp::Context* _cxt_)"
  "{\n"
  "   std::cout << _cxt_ << \'\\n\';\n"
  "   delete _cxt_;\n"
  "}\n"
  // inject the entry into the pipeline
  "void Steve_app::ingress(fp::Context* _cxt_)"
  "{\n"
  "   App_cxt* a = new App_cxt(*_cxt_);\n"
  "   delete _cxt_;\n"
  "   _cxt_ = a;\n"
  "   " + entry_code() +
  "}\n";
  
  write_hpp(hpp);
  write_cpp(code);
}



} // namespace steve