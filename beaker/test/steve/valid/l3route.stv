foreign def puts(char[]) -> int;

layout ethernet
{
	src : uint(48);
	dst : uint(48);
	type : uint(16);
}

layout ipv4
{
  version_ihl : uint(8);
  dscp_ecn    : uint(8);
  len         : uint(16);
	id					: uint(16);
	fragment    : uint(16);
  ttl         : uint(8);
  protocol    : uint(8);
  checksum    : uint(16);
  src         : uint(32);
  dst         : uint(32);
}


decoder start eth_d(ethernet)
{
	extract ethernet.dst;
	extract ethernet.src;
	extract ethernet.type;
	if (ethernet.type >= 0x600)
	  	// The next header is IPv4 if the type field is 0x800.
	    match (ethernet.type) {
	      case 0x800: decode ipv4_d;
	    }
	// If its not IPv4, processing ends and the packet is
	// implicitly dropped.
}


decoder ipv4_d(ipv4)
{
	extract ipv4.version_ihl; // Needed for ihl.
	extract ipv4.src; // Extract the IP addresses.
	extract ipv4.dst;
	extract ipv4.ttl; // We need ttl to decrement.

	// Drop on expired packets.
	if (ipv4.ttl == 0) drop;
	// Proceed to the learn table after advancing by ihl
	goto learn advance (ipv4.version_ihl & 0x0f) * 4;
}

// This event handles the actual "learning."
event learn_ip
	requires(ipv4.src) // It will learn src IP addresses.
{
	// This first entry prevents the same address from causing
	// this event twice. It sends the packet straight to routing.
	insert
	[timeout = 30]
	{ ipv4.src } -> { goto route; }
	into learn;

	// This establishes the IP address to port mapping.
	// Any packet whose dst address matches the current packet's
	// src address will be forwarded to the current packet's
	// ingress port.
	insert
	[timeout = 30, egress = in_port]
	{ ipv4.src } ->
	{
		set ipv4.ttl = ipv4.ttl - 1; // Decrement ttl.
		output egress;
	}
	into route;
}


exact_table learn(ipv4.src)
{
  miss ->
  {
		// puts("miss");
		raise learn_ip;
    goto route;
  }
}


// This ultimately decides where to forward packets based on
// their destination IP.
exact_table route(ipv4.dst)
	requires(ipv4.ttl)
{
	miss -> {
		// puts("flood");
		set ipv4.ttl = ipv4.ttl - 1; // Decrement ttl
		output flood; // Flood on all unlearned addresses.
	}
}
